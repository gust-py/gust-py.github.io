<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Galáxia Interativa - MHC3000</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter, Arial, Helvetica, sans-serif}
  body{display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{display:block; touch-action:none; background:transparent}
  #fallback{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,0.45);padding:8px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="fallback">Toque ou clique em uma estrela para viajar • Esc para sair do sistema</div>

<script>
/* ---------- CONFIGURAÇÕES E ESTADO ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

let DPR = Math.max(1, window.devicePixelRatio || 1);
let centerX = 0, centerY = 0;
let GALAXY_RADIUS = 0;

// Número base — ajustado dinamicamente em resize para evitar lag
const BASE_PARTICLES = 2000;
let NUM_PARTICLES = BASE_PARTICLES;

const NUM_ARMS = 7;
const SPIRAL_FACTOR = 5;
const ARM_SPREAD = 0.12;
const CAMERA_SPEED = 0.009;

let INCLINATION_START = 0 * Math.PI/180;
let INCLINATION_END = 0;

let camera_angle = 0;
let inclination = INCLINATION_START;

/* viagem interestelar */
let traveling = false;
let travel_progress = 0;
let travel_target = null;

/* estado visualização */
let viewing_system = null;
let zoom_progress = 0;

/* botão X */
let button_rect = { x:0, y:0, w:0, h:0 };

/* partículas / sistemas */
let particles = [];

/* ---------- UTILITÁRIOS ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function gaussianRandom(mean=0, stddev=1){
  let u=0,v=0;
  while(u===0) u = Math.random();
  while(v===0) v = Math.random();
  let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  return num*stddev + mean;
}
function randomChoiceWeighted(arr, weights){
  let sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<arr.length;i++){
    r -= weights[i];
    if(r<=0) return arr[i];
  }
  return arr[arr.length-1];
}

/* ---------- REDIMENSIONAMENTO E LOD ---------- */
function resizeCanvas(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  // canvas em pixels de dispositivo
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  // mostrar no tamanho CSS correto
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';

  centerX = canvas.width / 2;
  centerY = canvas.height / 2;
  GALAXY_RADIUS = Math.min(canvas.width, canvas.height) / 2 - 80 * DPR;

  // LOD: reduz partículas em telas pequenas / baixa resolução
  if(window.innerWidth < 700) NUM_PARTICLES = Math.max(700, Math.floor(BASE_PARTICLES * 0.5));
  else if(window.innerWidth < 1200) NUM_PARTICLES = Math.max(1000, Math.floor(BASE_PARTICLES * 0.75));
  else NUM_PARTICLES = BASE_PARTICLES;

  // botão tamanho recalculado
  button_rect.w = button_rect.h = Math.round(72 * DPR);

  // reconstrói partículas para novo GALAXY_RADIUS / NUM_PARTICLES
  rebuildParticles();
}
window.addEventListener('resize', resizeCanvas);

/* ---------- CRIAR ENTIDADES (mimetizando o Python) ---------- */
function make_black_hole(){
  let accretion = [];
  const num_acc = 700;
  for(let i=0;i<num_acc;i++){
    accretion.push({
      radius: 60 + Math.random()*160,
      angle: Math.random()*Math.PI*2,
      speed: 0.002 + Math.random()*0.006,
      size: Math.random()>0.75?2:1
    });
  }
  return {
    is_black_hole: true,
    name: 'MHC3000',
    accretion: accretion,
    color: [255,255,255],
    size: 8 * DPR
  };
}

function make_system(index){
  let arm_index = index % NUM_ARMS;
  let r = GALAXY_RADIUS * Math.pow(Math.random(), 1.5);
  // defender contra GALAXY_RADIUS = 0
  if(GALAXY_RADIUS <= 0) GALAXY_RADIUS = Math.max(200 * DPR, Math.min(window.innerWidth, window.innerHeight) / 3);
  let base_angle = arm_index * 2 * Math.PI / NUM_ARMS;
  let theta = base_angle + SPIRAL_FACTOR * (r / GALAXY_RADIUS) + gaussianRandom(0, ARM_SPREAD);
  let angular_speed = 0.05 / (r + 5);

  let brightness = Math.max(50, Math.floor(255 * (1 - r / GALAXY_RADIUS)));
  let color = [brightness, brightness, brightness];

  let num_planets = 2 + Math.floor(Math.random()*3); // 2-4
  let planets = [];
  let orbit_start = 40 + Math.floor(Math.random()*30);
  let gap_min = 40, gap_max = 90;

  for(let p_i=0; p_i<num_planets; p_i++){
    let orbit;
    if(p_i === 0) orbit = orbit_start + Math.floor((Math.random()*16)-8);
    else orbit = planets[planets.length-1].radius + gap_min + Math.floor(Math.random()*(gap_max-gap_min));
    let size = 6 + Math.floor(Math.random()*9); // 6-14
    let speed = 0.006 + (Math.random()*0.005 - 0.002);
    let angle = Math.random()*Math.PI*2;
    let ptype = randomChoiceWeighted(['rocky','gas','ringed'], [55,30,15]);

    let moons = [];
    let num_moons = randomChoiceWeighted([0,1,2],[60,30,10]);
    for(let m=0;m<num_moons;m++){
      moons.push({
        radius: 6 + Math.floor(Math.random()*9),
        size: 1 + Math.floor(Math.random()*3),
        angle: Math.random()*Math.PI*2,
        speed: 0.01 + Math.random()*0.03
      });
    }

    planets.push({
      radius: orbit,
      size: size * DPR,
      angle: angle,
      speed: speed,
      type: ptype,
      moons: moons
    });
  }

  // cinturão
  let inner, outer;
  if(planets.length >= 2){
    inner = planets[planets.length-2].radius + 20;
    outer = planets[planets.length-1].radius + 30;
  } else {
    inner = planets[planets.length-1].radius + 25;
    outer = planets[planets.length-1].radius + 80;
  }
  let belt_radius = (inner + outer)/2;
  let belt_width = Math.max(8, (outer - inner)/2);
  let num_asteroids = 80 + Math.floor(Math.random()*61);

  let asteroids = [];
  for(let i=0;i<num_asteroids;i++){
    asteroids.push({
      radius: belt_radius + (Math.random()*belt_width - belt_width/2),
      angle: Math.random()*Math.PI*2,
      speed: 0.0006 + Math.random()*0.001,
      size: Math.random()>0.8?2:1
    });
  }

  return {
    r: r,
    theta: theta,
    angular_speed: angular_speed,
    color: color,
    planets: planets,
    asteroids: asteroids,
    name: `MH°${index+1}`
  };
}

function rebuildParticles(){
  particles = [];
  for(let i=0;i<NUM_PARTICLES;i++){
    particles.push(make_system(i));
  }
  particles.push(make_black_hole());
}

/* ---------- DESENHO DE PLANETAS ---------- */
function drawPlanet(px, py, planet, scale){
  let planet_size = Math.max(1, Math.round((planet.size * scale) / 6));
  ctx.beginPath(); ctx.arc(px, py, planet_size, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill();

  if(planet.type === 'ringed'){
    ctx.beginPath();
    ctx.ellipse(px, py, planet_size*2.2, planet_size*0.9, 0, 0, Math.PI*2);
    ctx.lineWidth = Math.max(1, Math.round(1 * DPR * scale * 0.6));
    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  for(let moon of planet.moons){
    moon.angle += moon.speed;
    let mx = px + moon.radius * Math.cos(moon.angle) * scale * 0.6;
    let my = py + moon.radius * Math.sin(moon.angle) * scale * 0.6;
    let msize = Math.max(1, Math.round(moon.size * scale / 6));
    ctx.beginPath(); ctx.arc(mx, my, msize, 0, Math.PI*2); ctx.fillStyle = 'rgb(180,180,180)'; ctx.fill();

    ctx.beginPath();
    ctx.arc(px, py, Math.max(1, Math.round(moon.radius * scale * 0.6)), 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(60,60,60,0.15)';
    ctx.lineWidth = 1; ctx.stroke();
  }
}

/* ---------- INPUT (mouse/touch/keyboard) ---------- */
function pointerToCanvas(e){
  if(e.touches && e.touches.length) return { x: e.touches[0].clientX * DPR, y: e.touches[0].clientY * DPR };
  return { x: (e.clientX || e.pageX) * DPR, y: (e.clientY || e.pageY) * DPR };
}
canvas.addEventListener('pointerdown', (ev)=>{
  let p = pointerToCanvas(ev);
  handleClick(p.x, p.y);
});
window.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Escape' || ev.key === 'Esc'){
    if(viewing_system){ viewing_system = null; zoom_progress = 0; }
  }
});

/* ---------- LÓGICA DE CLIQUE NAS PARTÍCULAS ---------- */
function handleClick(mx, my){
  if(viewing_system){
    let pad = Math.round(20 * DPR);
    let bx = canvas.width - button_rect.w - pad;
    let by = pad;
    if(mx >= bx && mx <= bx + button_rect.w && my >= by && my <= by + button_rect.h){
      viewing_system = null; zoom_progress = 0;
      return;
    }
  }

  for(let p of particles){
    let screen_x, screen_y, hitbox = 6 * DPR;
    if(p.is_black_hole){
      screen_x = centerX;
      screen_y = centerY;
      hitbox = 90 * DPR;
    } else {
      let x = p.r * Math.cos(p.theta);
      let y = p.r * Math.sin(p.theta);
      y *= Math.cos(inclination);
      let x_rot = x*Math.cos(camera_angle) - y*Math.sin(camera_angle);
      let y_rot = x*Math.sin(camera_angle) + y*Math.cos(camera_angle);
      screen_x = centerX + x_rot;
      screen_y = centerY + y_rot;
      hitbox = 6 * DPR;
    }
    if(Math.hypot(mx - screen_x, my - screen_y) < hitbox){
      traveling = true;
      travel_progress = 0;
      travel_target = p;
      return;
    }
  }
}

/* ---------- UPDATE E DRAW ---------- */
let lastTime = performance.now();
function update(dt){
  camera_angle += CAMERA_SPEED * dt * 0.06;
  if(inclination > INCLINATION_END) inclination -= Math.PI/180 * 0.05 * dt * 0.06;

  if(traveling){
    travel_progress += 0.02 * dt * 0.06;
    travel_progress = clamp(travel_progress, 0, 1);
    if(travel_progress >= 1.0){
      traveling = false;
      viewing_system = travel_target;
      zoom_progress = 0;
    }
  }

  for(let p of particles){
    if(p.is_black_hole) continue;
    p.theta += p.angular_speed * dt * 0.06;
    for(let a of p.asteroids) a.angle += a.speed * dt * 0.06;
  }
  let bh = particles.find(x => x.is_black_hole);
  if(bh){
    for(let a of bh.accretion) a.angle += a.speed * dt * 0.06;
  }
}

function draw(){
  // limpa tela (usando tamanho real do canvas)
  ctx.fillStyle = 'black';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // se viajando — rastro central
  if(traveling){
    let t = travel_progress;
    let r_trail = Math.round((8 + 60*(t*t)) * DPR);
    let alpha = Math.round(255 * t);
    ctx.save();
    ctx.globalAlpha = clamp(alpha/255, 0.25, 0.95);
    ctx.beginPath();
    ctx.arc(centerX, centerY, r_trail, 0, Math.PI*2);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.restore();
    return;
  }

  if(viewing_system){
    if(zoom_progress < 1.0) zoom_progress = Math.min(1.0, zoom_progress + 0.03);
    let cx = centerX, cy = centerY;
    let scale = 0.6 + zoom_progress*4.5;

    if(viewing_system.is_black_hole){
      ctx.beginPath();
      ctx.arc(cx, cy, Math.round(55 * scale * DPR), 0, Math.PI*2);
      ctx.fillStyle = 'black'; ctx.fill();

      ctx.beginPath();
      ctx.arc(cx, cy, Math.round(65 * scale * DPR), 0, Math.PI*2);
      ctx.lineWidth = Math.max(1, Math.round(2 * DPR)); ctx.strokeStyle = 'white'; ctx.stroke();
      ctx.lineWidth = 1;

      for(let a of viewing_system.accretion){
        let ax = cx + a.radius * Math.cos(a.angle) * scale * 0.45;
        let ay = cy + a.radius * Math.sin(a.angle) * scale * 0.45;
        let size = Math.max(1, Math.round(a.size * (scale*0.3) * DPR));
        ctx.beginPath(); ctx.arc(ax, ay, size, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill();
      }

      drawCloseButton();
      ctx.font = `${Math.round(20 * DPR)}px Arial`;
      ctx.fillStyle = 'white';
      ctx.fillText(viewing_system.name || 'MHC3000', Math.round(20*DPR), Math.round(30*DPR));
    } else {
      ctx.beginPath(); ctx.arc(cx, cy, Math.round(10 * scale * DPR), 0, Math.PI*2);
      ctx.fillStyle = `rgb(${viewing_system.color[0]},${viewing_system.color[1]},${viewing_system.color[2]})`; ctx.fill();

      for(let ast of viewing_system.asteroids){
        let ax = cx + ast.radius * Math.cos(ast.angle) * scale * 0.5;
        let ay = cy + ast.radius * Math.sin(ast.angle) * scale * 0.5;
        let size = Math.max(1, Math.round(ast.size * (scale*0.25) * DPR));
        ctx.beginPath(); ctx.arc(ax, ay, size, 0, Math.PI*2); ctx.fillStyle = 'rgb(150,150,150)'; ctx.fill();
      }

      for(let planet of viewing_system.planets){
        planet.angle += planet.speed;
        let px = cx + planet.radius * Math.cos(planet.angle) * scale * 0.55;
        let py = cy + planet.radius * Math.sin(planet.angle) * scale * 0.55;

        ctx.beginPath();
        ctx.arc(cx, cy, Math.max(1, Math.round(planet.radius * scale * 0.55)), 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(70,70,70,0.25)'; ctx.lineWidth = 1; ctx.stroke();

        drawPlanet(px, py, planet, scale);
      }

      drawCloseButton();
      ctx.font = `${Math.round(20 * DPR)}px Arial`;
      ctx.fillStyle = 'white';
      ctx.fillText(viewing_system.name, Math.round(20*DPR), Math.round(30*DPR));
    }
    return;
  }

  // desenhar galáxia (partículas)
  for(let p of particles){
    if(p.is_black_hole){
      ctx.beginPath(); ctx.arc(centerX, centerY, Math.max(1, Math.round(p.size)), 0, Math.PI*2);
      ctx.fillStyle = 'white'; ctx.fill();
      continue;
    }

    let x = p.r * Math.cos(p.theta);
    let y = p.r * Math.sin(p.theta);
    y *= Math.cos(inclination);
    let xr = x*Math.cos(camera_angle) - y*Math.sin(camera_angle);
    let yr = x*Math.sin(camera_angle) + y*Math.cos(camera_angle);

    let sx = centerX + xr;
    let sy = centerY + yr;

    let c = p.color[0];
    ctx.fillStyle = `rgb(${c},${c},${c})`;
    // desenhar ponto simples e rápido
    ctx.fillRect(Math.round(sx), Math.round(sy), Math.max(1, Math.round(1 * DPR)), Math.max(1, Math.round(1 * DPR)));
  }
}

/* ---------- BOTÃO FECHAR ---------- */
function drawCloseButton(){
  let pad = Math.round(20 * DPR);
  button_rect.w = button_rect.h = Math.round(72 * DPR);
  button_rect.x = canvas.width - button_rect.w - pad;
  button_rect.y = pad;

  ctx.fillStyle = 'white';
  ctx.fillRect(button_rect.x, button_rect.y, button_rect.w, button_rect.h);
  ctx.fillStyle = 'black';
  ctx.font = `${Math.round(44 * DPR)}px Arial`;
  ctx.fillText('X', button_rect.x + Math.round(22*DPR), button_rect.y + Math.round(50*DPR));
}

/* ---------- LOOP PRINCIPAL ---------- */
function loop(now){
  let dt = (now - lastTime) / 16.6667;
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- INICIALIZAÇÃO ---------- */
function start(){
  resizeCanvas(); // também chama rebuildParticles
  lastTime = performance.now();
  requestAnimationFrame(loop);
}
start();

/* ---------- DEBUG / HELP ---------- */
window.__galaxy = { particles, rebuild: rebuildParticles };

/* ---------- ÚTEIS ---------- */
function random(min,max){ return Math.random()*(max-min)+min; }

</script>
</body>
  </html>
