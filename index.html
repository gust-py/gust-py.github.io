<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AN-74 Flight Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background: #000; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; pointer-events: none; text-shadow: 1px 1px 2px black; }
        .controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: all; }
        
        button { 
            padding: 10px 20px; cursor: pointer; background: #222; color: #0f0; border: 1px solid #0f0; font-weight: bold;
        }
        button:active { background: #0f0; color: #000; }
        
        #joystick-container {
            position: absolute; bottom: 40px; left: 40px; width: 150px; height: 150px;
            background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid #0f0;
            pointer-events: all; touch-action: none;
        }
        #joystick-knob {
            position: absolute; width: 50px; height: 50px; background: #0f0;
            border-radius: 50%; top: 50px; left: 50px; transform: translate(0, 0);
        }
        .throttle-container {
            position: absolute; bottom: 40px; left: 220px; display: flex; flex-direction: column; align-items: center; color: #0f0;
        }
        input[type=range] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 20px; height: 150px; }
    </style>
</head>
<body>

    <div id="ui">
        <h2>AN-74 TELEMETRY</h2>
        <div id="stats">
            SPEED: 0 kts<br>
            ALT: 0 m<br>
            STATUS: ENGINES OFF<br>
            REVERSE: OFF
        </div>
    </div>

    <div class="controls">
        <button id="powerBtn">TURN ON</button>
        <button id="revBtn">REVERSE OFF</button>
    </div>

    <div class="throttle-container">
        <span>THR</span>
        <input type="range" id="throttle" min="0" max="1" step="0.01" value="0">
    </div>

    <div id="joystick-container">
        <div id="joystick-knob"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

        // --- CONFIGURAÇÃO SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(500, 1000, 500);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- CONSTANTES FÍSICAS ---
        const earthRadius = 637000; 
        let speedKts = 0;
        let engineOn = false;
        let isReverse = false;
        let throttle = 0;
        let airplane = new THREE.Group();
        let joystick = { x: 0, y: 0 }; // -1 a 1

        // --- PLANETA E PISTA ---
        const planetGeo = new THREE.SphereGeometry(earthRadius, 128, 128);
        const planetMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
        const planet = new THREE.Mesh(planetGeo, planetMat);
        planet.position.y = -earthRadius;
        scene.add(planet);

        // Pista: 750m x 100m
        const runwayGeo = new THREE.PlaneGeometry(100, 750);
        const runwayMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        const runway = new THREE.Mesh(runwayGeo, runwayMat);
        runway.rotation.x = Math.PI / 2;
        runway.position.y = 0.05; // Levemente acima do chão para evitar z-fighting
        scene.add(runway);

        // --- ATMOSFERA (3 Faixas) ---
        const atmoColors = [0x87CEEB, 0x4682B4, 0x000080];
        const atmoAltitudes = [3500, 15000, 30000];
        atmoAltitudes.forEach((alt, i) => {
            const geo = new THREE.SphereGeometry(earthRadius + alt, 64, 64);
            const mat = new THREE.MeshBasicMaterial({ color: atmoColors[i], transparent: true, opacity: 0.15, side: THREE.BackSide });
            const layer = new THREE.Mesh(geo, mat);
            layer.position.copy(planet.position);
            scene.add(layer);
        });

        // --- CARREGAR AN-74 ---
        const loader = new GLTFLoader();
        // Nota: Como não tenho o arquivo local, criamos um placeholder
        const placeholderGeo = new THREE.BoxGeometry(2, 0.5, 5);
        const placeholderMat = new THREE.MeshStandardMaterial({color: 0xffffff});
        const placeholder = new THREE.Mesh(placeholderGeo, placeholderMat);
        airplane.add(placeholder); 
        // Se você tiver o GLB, use: loader.load('an74.glb', (gltf) => { airplane.add(gltf.scene); });
        
        scene.add(airplane);
        airplane.position.set(0, 1, 300); // Começa na cabeceira da pista

        // --- LOGICA DO JOYSTICK ---
        const knob = document.getElementById('joystick-knob');
        const container = document.getElementById('joystick-container');
        
        container.addEventListener('pointermove', (e) => {
            if (e.buttons === 1) {
                const rect = container.getBoundingClientRect();
                let x = (e.clientX - rect.left - 75) / 75;
                let y = (e.clientY - rect.top - 75) / 75;
                x = Math.max(-1, Math.min(1, x));
                y = Math.max(-1, Math.min(1, y));
                joystick.x = x;
                joystick.y = -y; // Inverter para "puxar" subir
                knob.style.transform = `translate(${x * 50}px, ${y * 50}px)`;
            }
        });

        container.addEventListener('pointerup', () => {
            joystick.x = 0; joystick.y = 0;
            knob.style.transform = `translate(0, 0)`;
        });

        // --- BOTÕES ---
        document.getElementById('powerBtn').onclick = (e) => {
            engineOn = !engineOn;
            e.target.innerText = engineOn ? "TURN OFF" : "TURN ON";
        };
        document.getElementById('revBtn').onclick = (e) => {
            isReverse = !isReverse;
            e.target.innerText = isReverse ? "REVERSE ON" : "REVERSE OFF";
        };
        document.getElementById('throttle').oninput = (e) => {
            throttle = parseFloat(e.target.value);
        };

        // --- LOOP DE ANIMAÇÃO E FÍSICA ---
        const clock = new THREE.Clock();

        function update() {
            const dt = clock.getDelta();
            const alt = airplane.position.y;

            // 1. Motor e Velocidade
            let thrust = engineOn ? throttle * 100 : 0;
            if (isReverse) thrust *= -0.5;
            
            // Arrasto aerodinâmico simples
            const drag = (speedKts * speedKts) * 0.001;
            speedKts += (thrust - drag) * dt;
            if (speedKts < 0) speedKts = 0;

            // 2. Comportamento Chão vs Ar
            if (alt <= 0.2) {
                // NO CHÃO
                airplane.position.y = 0.2;
                speedKts *= 0.99; // Atrito da pista
                
                // Yaw no chão (Joystick X vira o nariz)
                airplane.rotation.y -= joystick.x * dt * 1.5;
                airplane.rotation.z = 0;
                airplane.rotation.x = 0;

                // Decolagem: precisa de 150kts + joystick pra trás
                if (speedKts > 150 && joystick.y > 0.1) {
                    airplane.position.y += 0.5;
                }
            } else {
                // NO AR
                // Rotação suave (Roll 30 graus e Pitch)
                const targetRoll = -joystick.x * 0.52; // 30 deg
                const targetPitch = joystick.y * 0.4;
                
                airplane.rotation.z = THREE.MathUtils.lerp(airplane.rotation.z, targetRoll, 0.05);
                airplane.rotation.x = THREE.MathUtils.lerp(airplane.rotation.x, targetPitch, 0.05);
                
                // Yaw baseado no roll (curva coordenada)
                airplane.rotation.y -= airplane.rotation.z * dt * 0.5;

                // Sustentação e Stall
                const lift = (speedKts / 150) * (1 + joystick.y * 0.5);
                const gravity = 1.0;
                
                // Movimento vertical
                airplane.position.y += (lift - gravity) * 20 * dt;

                // Efeito de Stall (nariz cai se lento)
                if (speedKts < 130) {
                    airplane.rotation.x = THREE.MathUtils.lerp(airplane.rotation.x, 0.5, 0.02);
                    airplane.position.y -= 15 * dt;
                }
            }

            // 3. Avanço espacial
            airplane.translateZ(speedKts * dt * 0.5);

            // Câmera segue o avião
            const relativeCameraOffset = new THREE.Vector3(0, 5, -15);
            const cameraOffset = relativeCameraOffset.applyMatrix4(airplane.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(airplane.position);

            // UI
            document.getElementById('stats').innerHTML = `
                SPEED: ${Math.round(speedKts)} kts<br>
                ALT: ${Math.round(alt)} m<br>
                STATUS: ${engineOn ? (speedKts < 150 && alt > 1 ? 'STALL WARNING' : 'FLYING') : 'GLIDING'}<br>
                REVERSE: ${isReverse ? 'ACTIVE' : 'OFF'}
            `;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        animate();

        // Ajuste de janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
