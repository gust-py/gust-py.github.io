<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Space Engine Web — v0.1 (realista)</title>
  <style>
    :root{
      --ui-bg: rgba(0,0,0,0.45);
      --accent: #66ccff;
      --muted: #bbbbbb;
    }
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter,system-ui,Roboto,Segoe UI,Arial}
    #container{width:100%;height:100%;position:relative;overflow:hidden}
    canvas{display:block}
    #ui{
      position: absolute;
      left: 12px;
      top: 12px;
      background: var(--ui-bg);
      padding: 10px;
      border-radius: 8px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      min-width: 220px;
    }
    #ui h1{margin:0 0 6px 0;font-size:15px}
    #ui label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px;align-items:center;margin-top:8px}
    button{background:var(--accent);border:0;padding:8px 10px;border-radius:6px;color:#001;cursor:pointer;font-weight:600}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--muted)}
    #info{position:absolute;right:12px;top:12px;background:var(--ui-bg);padding:8px;border-radius:8px;font-size:13px;min-width:180px}
    a.small{color:var(--muted);font-size:12px;text-decoration:none}
    .muted{color:var(--muted);font-size:12px}
    footer{position:absolute;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div id="container"></div>

  <div id="ui">
    <h1>Space Engine — v0.1</h1>
    <div class="muted">Versão realista inicial: estrela, planeta, lua — órbitas Keplerianas</div>

    <label>Velocidade do tempo: <span id="speedLabel">1×</span></label>
    <input id="speed" type="range" min="0" max="2000" value="1" step="1" />

    <div class="row">
      <button id="pauseBtn">Pausar</button>
      <button id="resetBtn" class="secondary">Resetar câmera</button>
    </div>

    <label>Parâmetros do planeta</label>
    <div class="row">
      <button id="toggleOrbit" class="secondary">Mostrar órbita</button>
      <div style="flex:1"></div>
    </div>

    <label class="muted">Controles: mouse arrasta / scroll zoom / WASD move</label>
    <div style="height:6px"></div>
    <a class="small" href="#" id="publishHint">Pronto pra GitHub Pages</a>
  </div>

  <div id="info">
    <div><strong id="objName">Sol — Sistema Demo</strong></div>
    <div class="muted" id="meta">Distância planeta-sol: <span id="dist">—</span></div>
    <div class="muted" id="meta2">Período orbital (simulado): <span id="period">—</span></div>
  </div>

  <footer>Projeto experimental — Space Engine Web • Use devtools se quiser ajustar</footer>

<script type="module">
/*
  Space Engine Web v0.1
  - Three.js via CDN modules
  - Órbita elíptica, inclinação, rotação axial, lua
  - UI simples para velocidade, pausa, orbit toggle
  - Projetado para rodar em GitHub Pages (static)
*/

/* ---------- imports (CDN) ---------- */
import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js';

/* ---------- cena, câmera, renderer ---------- */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1e8);
camera.position.set(0, 30, 120);

/* ---------- controls ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.12;
controls.screenSpacePanning = false;

/* WASD-based relative flight (assist) */
const keyState = {};
window.addEventListener('keydown', (e)=>keyState[e.key.toLowerCase()] = true);
window.addEventListener('keyup', (e)=>keyState[e.key.toLowerCase()] = false);

/* ---------- unidades e escala (real -> visual) ----------
   We'll use astronomical units (AU) as base for realism:
   1 AU = 149,597,870 km.
   For visuals we compress distances by SCALE (smaller => visible).
*/
const AU = 149597870; // in km (informational)
const SCALE = 0.0000025; // compress factor to make distances visible
// For display we still calculate period in "days" if we use Newton's form.

const G = 6.67430e-20; // gravitational constant in km^3 kg^-1 s^-2 (approx for km units) - for info but we will use Kepler-ish approach

/* ---------- Star (sol) ---------- */
const starGroup = new THREE.Group();
scene.add(starGroup);

const starRadiusKm = 695700; // sun radius in km
const starVisRadius = Math.max(3, starRadiusKm * SCALE * 0.0005); // compress more for visibility
const starGeo = new THREE.SphereGeometry(starVisRadius, 32, 32);
const starMat = new THREE.MeshBasicMaterial({ color: 0xffee88, emissive: 0xffee88 });
const starMesh = new THREE.Mesh(starGeo, starMat);
starGroup.add(starMesh);

// star light: physically bright point light
const starLight = new THREE.PointLight(0xfff6d8, 2.5, 0, 2); // intensity tuned
starLight.position.set(0,0,0);
scene.add(starLight);

/* ---------- starfield (points) ---------- */
function makeStarfield(count=4000, radius=1e6){
  const geom = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = (0.3 + Math.random()*0.7) * radius; // radius variation
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    pos[i*3] = x * SCALE; pos[i*3+1] = y * SCALE; pos[i*3+2] = z * SCALE;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const material = new THREE.PointsMaterial({ size: 0.6, sizeAttenuation: true, color: 0xffffff, opacity:0.9, transparent:true});
  const points = new THREE.Points(geom, material);
  scene.add(points);
}
makeStarfield(3000, 8e6);

/* ---------- Planet (Kepler-like orbit) ---------- */
/*
  We'll parametrize the planet by:
    a = semi-major axis (km)
    e = eccentricity (0=circle)
    incl = inclination (deg)
    omega = argument of periapsis (deg)
    Omega = longitude of ascending node (deg)
    M0 = mean anomaly at epoch (deg)
  We'll simply use parametric ellipse (not solving Kepler's equation for speed)
  For time propagation we advance an angle theta = 2π * t / T, where T is orbital period computed by Kepler's 3rd law.
*/

// planet parameters (realistic-ish values but scaled)
const planet = {
  name: 'MH-1',
  mass: 5.972e24,       // kg (earth mass) — informational
  a_km: 1.0 * 1.0 * AU, // semi-major axis in km (1 AU)
  e: 0.0167,            // small eccentricity like Earth
  incl_deg: 3.0,        // slight tilt
  omega_deg: 0,         // argument of periapsis
  Omega_deg: 0,         // longitude of ascending node
  radius_km: 6371,      // planet physical radius
  color: 0x6699ff,
  axialTilt_deg: 23.4,
  rotationPeriod_hours: 24 // planet rotation (for day)
};

// derived visuals
planet.visRadius = Math.max(1, planet.radius_km * SCALE * 0.02);
planet.a_vis = planet.a_km * SCALE;
planet.b_vis = planet.a_vis * Math.sqrt(1 - planet.e*planet.e);

// compute orbital period (Kepler's third law) using central star mass ~ sunMass
const sunMass = 1.989e30; // kg
// T^2 = 4π^2 a^3 / (G * (M+m)), we use G in km^3 kg^-1 s^-2 => careful units - approximate for display
const a_m = planet.a_km * 1000;
const G_SI = 6.67430e-11;
const T_seconds = Math.sqrt(4*Math.PI*Math.PI * Math.pow(a_m,3) / (G_SI * (sunMass + planet.mass)));
const T_days = T_seconds / (60*60*24);

// create planet mesh
const planetGroup = new THREE.Group();
scene.add(planetGroup);

const planetGeo = new THREE.SphereGeometry(planet.visRadius, 32, 32);
const planetMat = new THREE.MeshStandardMaterial({ color: planet.color, metalness: 0.05, roughness: 0.8 });
const planetMesh = new THREE.Mesh(planetGeo, planetMat);
planetMesh.castShadow = true;
planetMesh.receiveShadow = true;
planetGroup.add(planetMesh);

// axial tilt group
planetMesh.rotation.z = THREE.MathUtils.degToRad(planet.axialTilt_deg);

/* ---------- Moon ---------- */
const moon = {
  name: 'MH-1 I',
  a_km: 384400, // km from planet (like Moon)
  e: 0.0549,
  radius_km: 1737,
  visRadius: Math.max(0.5, 1737 * SCALE * 0.02)
};
moon.a_vis = moon.a_km * SCALE;
moon.b_vis = moon.a_vis * Math.sqrt(1 - moon.e*moon.e);

const moonGroup = new THREE.Group();
planetGroup.add(moonGroup);
const moonGeo = new THREE.SphereGeometry(moon.visRadius, 24, 24);
const moonMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness:0.0, roughness:0.9 });
const moonMesh = new THREE.Mesh(moonGeo, moonMat);
moonGroup.add(moonMesh);

/* ---------- orbit helper (line) ---------- */
let orbitLine = null;
function buildOrbitLine(a_vis, b_vis, segments=256, tiltDeg=0, color=0x8888ff){
  if(orbitLine) scene.remove(orbitLine);
  const pts = [];
  for(let i=0;i<=segments;i++){
    const t = i/segments * Math.PI*2;
    const x = a_vis * Math.cos(t);
    const z = b_vis * Math.sin(t);
    pts.push(new THREE.Vector3(x,0,z));
  }
  const geom = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({color: color, opacity:0.6, transparent:true});
  orbitLine = new THREE.LineLoop(geom, mat);
  orbitLine.rotation.x = THREE.MathUtils.degToRad(tiltDeg);
  scene.add(orbitLine);
}
let showOrbit = true;
buildOrbitLine(planet.a_vis, planet.b_vis, 512, planet.incl_deg, 0x66ccff);

/* ---------- HUD / UI ---------- */
const speedSlider = document.getElementById('speed');
const speedLabel = document.getElementById('speedLabel');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const toggleOrbitBtn = document.getElementById('toggleOrbit');

let timeSpeed = parseFloat(speedSlider.value); // multiplier in seconds per frame units
let paused = false;

speedSlider.addEventListener('input', ()=>{
  timeSpeed = parseFloat(speedSlider.value);
  speedLabel.textContent = timeSpeed.toFixed(0) + '×';
});

pauseBtn.addEventListener('click', ()=>{
  paused = !paused;
  pauseBtn.textContent = paused ? 'Continuar' : 'Pausar';
});

resetBtn.addEventListener('click', ()=>{
  camera.position.set(0, 30, 120);
  controls.target.set(0,0,0);
  controls.update();
});

toggleOrbitBtn.addEventListener('click', ()=>{
  showOrbit = !showOrbit;
  if(orbitLine) orbitLine.visible = showOrbit;
  toggleOrbitBtn.classList.toggle('secondary', !showOrbit);
  toggleOrbitBtn.textContent = showOrbit ? 'Ocultar órbita' : 'Mostrar órbita';
});

/* ---------- simulation state ---------- */
let simTime = 0; // seconds elapsed in simulation (scaled)
const realSecondPerFrame = 1/60; // baseline
const displayDist = document.getElementById('dist');
const displayPeriod = document.getElementById('period');
document.getElementById('objName').textContent = `${planet.name} (demo)`;

// initial display
displayPeriod.textContent = `${T_days.toFixed(1)} dias`;

/* ---------- orbit math (parametric) ---------- */
/*
 param t from 0..1 around orbit => theta = 2π * t
 position (in orbital plane) = (a cos θ, 0, b sin θ)
 apply rotation by Omega, omega, inclination via Euler rotations if needed
 We'll keep simple: apply inclination as rotation about X
*/
function computeOrbitPosition(a_vis, b_vis, theta, incl_deg=0){
  const x = a_vis * Math.cos(theta);
  const z = b_vis * Math.sin(theta);
  const pos = new THREE.Vector3(x, 0, z);
  // apply inclination rotation around x axis
  pos.applyAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(incl_deg));
  return pos;
}

/* ---------- animation loop ---------- */
let last = performance.now();
let fpsMeasureTime = performance.now();
let frameCount = 0;

function animate(now){
  const dtMs = now - last;
  last = now;
  const dt = dtMs / 1000.0;
  // adaptive time step: simulation seconds to advance per real second
  const simSecondsAdvance = (paused ? 0 : dt * timeSpeed * 3600); // timeSpeed × hours per real second (multiply to get notable motion)
  simTime += simSecondsAdvance;

  // planet orbital progress: theta = 2π * t / T_seconds
  const theta = (simTime % T_seconds) / T_seconds * Math.PI * 2;
  // compute planet position
  const planetPos = computeOrbitPosition(planet.a_vis, planet.b_vis, theta, planet.incl_deg);
  planetGroup.position.copy(planetPos);

  // moon orbit around planet: faster period, use separate param
  const moonPeriodSec = 27.3 * 24*3600; // ~27.3 days
  const moonTheta = (simTime % moonPeriodSec) / moonPeriodSec * Math.PI * 2;
  const moonPos = computeOrbitPosition(moon.a_vis, moon.b_vis, moonTheta, 5); // slight tilt
  moonGroup.position.set(moonPos.x, moonPos.y, moonPos.z);

  // planet axial rotation (day)
  const daySeconds = planet.rotationPeriod_hours * 3600;
  const dayTheta = (simTime % daySeconds) / daySeconds * Math.PI * 2;
  planetMesh.rotation.y = dayTheta;

  // update UI distance (planet-star)
  const distVis = planetPos.length() / SCALE; // convert back to km approximately
  displayDist.textContent = `${(planetPos.length()/SCALE/1000).toFixed(0)} km (sim)`; // approximate

  // camera controls and WASD flight
  controls.update();
  const moveSpeed = 40 * dt * (1 + timeSpeed*0.02);
  if(keyState['w']) camera.position.add(controls.getDirection(new THREE.Vector3()).multiplyScalar(moveSpeed));
  if(keyState['s']) camera.position.add(controls.getDirection(new THREE.Vector3()).multiplyScalar(-moveSpeed));
  if(keyState['a']) camera.position.add(controls.getRight(new THREE.Vector3()).multiplyScalar(-moveSpeed));
  if(keyState['d']) camera.position.add(controls.getRight(new THREE.Vector3()).multiplyScalar(moveSpeed));
  if(keyState['q']) camera.position.y += moveSpeed;
  if(keyState['e']) camera.position.y -= moveSpeed;

  controls.update();

  renderer.render(scene, camera);

  // simple fps-adaptive LOD: if frame time too high, reduce star points (not heavy)
  frameCount++;
  if(now - fpsMeasureTime > 1000){
    const fps = frameCount / ((now - fpsMeasureTime)/1000);
    frameCount = 0; fpsMeasureTime = now;
    // adjust star count or renderer settings if fps low (basic)
    // (omitted heavy reallocation to keep code simple)
    // console.log('fps',fps);
  }

  requestAnimationFrame(animate);
}

/* ---------- responsive ---------- */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ---------- start ---------- */
requestAnimationFrame(animate);

/* ---------- helpers for controls (OrbitControls small ext) ---------- */
OrbitControls.prototype.getDirection = function(targetVec){
  // returns camera forward direction vector
  this.getPolarAngle(); // ensure internals
  const vec = targetVec || new THREE.Vector3();
  this.object.getWorldDirection(vec);
  return vec;
};
OrbitControls.prototype.getRight = function(targetVec){
  const dir = this.getDirection(new THREE.Vector3());
  return new THREE.Vector3().crossVectors(dir, this.object.up).normalize().multiplyScalar(-1);
};

</script>
</body>
</html>
